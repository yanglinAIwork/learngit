## RPC协议、Rest协议、SOAP协议区别

​		接口调用通常包含两个部分，序列化和通信协议。

​		常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；

​		通信比较流行的是http、soap、websockect，RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift

### 一、接口调用

​		`REST`严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上,但是不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。

​		http相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，相应的，如果采用http，无疑在你实现SDK之前，支持了所有语言，所以，现在开源中间件，基本最先支持的几个协议都包含RESTful。

​		`RPC`是我们常说的远程方法调用，通信协议大多采用二进制。rpc是基于tcp/ip协议之上的，但rpc限制了开发的语言环境。

​		RPC协议性能要高的多，例如Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到http的二倍。响应时间也更为出色。千万不要小看这点性能损耗，公认的，微服务做的比较好的，例如，netflix、阿里，曾经都传出过为了提升性能而合并服务。如果是交付型的项目，性能更为重要，因为你卖给客户往往靠的就是性能上微弱的优势。无论是Google、Amazon、netflix（据说很可能转向grpc），还是阿里，实际上内部都是采用性能更高的RPC方式。而对外开放的才是RESTful。

​			Rest 调用及测试都很方便，Rpc就显得有点麻烦，但是Rpc的效率是毋庸置疑的，所以建议在多系统之间采用Rpc，对外提供服务，Rest是很适合的，duboo在生产者和消费者两个微服务之间的通信采用的就是Rpc,无疑在服务之间的调用Rpc更变现的优秀

### 二、如何选择

- 如果需要更高的传输效率，需要服务发现、水平扩展等相关技术，可以选用rpc
- 如果想要调用简单，接口更加通用，与编程语言无关，可以选用基于http的restful

### 三、协议之间的区别

#### 1、SOAP协议

​		`SOAP`简单对象访问协议，是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息。

​		`SOAP`扩展：

​		webService三要素：SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)之一， soap用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口， uddi用来管理，分发，查询webService 。

#### 2、REST协议

​		`REST`表征状态转移（Representional State Transfer），其宗旨是从资源的角度来观察整个网络，分布在各处的资源由URI确定，而客户端的应用通过URI来获取资源的表征。获得这些表征致使这些应用程序转变了其状态。随着不断获取资源的表征，客户端应用不断地在转变着其状态。

#### 3、RPC协议

​		`RPC`远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。

​		`RPC`采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。

#### 4、RPC与REST调用例子

​		Marcus是一个农民，他有4头猪，12只鸡和3头奶牛。他现在模拟一个REST API，而我是客户端。如果我想用REST来请求当前的农场状态，我仅会问：“State？”Marcus会回答：“4头猪、12只鸡、3头奶牛”。<即农场Object>

​		这是REST最简单的一个例子。Marcus使用表征来传输农场状态。表征的句子很简单：“4头猪、12只鸡、3头奶牛”。
​		再往下看，看我如何让Marcus用REST方式添加2头奶牛？
​		按照常理，可以会这样说：Marcus，请在农场你再添加2头奶牛。难道这就是REST方式吗？难道就是通过这样的表征来传输状态的吗？不是的！这是一个远程过程调用，过程是给农场添加2头奶牛。<此时是`RPC`>
​		Marcus很愤怒地响应到：“400，Bad Request”，你到底是什么意思？
​		所以，让我们重新来一次。我们怎样做到REST方式呢？该怎样重新表征呢？
​		我：“Marcus，……4头猪、12只鸡、5头奶牛！” <`REST`的`POST`请求，接口不变>
​		Marcus：“好的”。
​		我：“Marcus，现在是什么状态？”
​		Marcus：“4头猪、12只鸡、5头奶牛”。
​		我：“好！”	<这才是用到了`REST`>

​		**为什么RPC也不够好？**
​		从逻辑角度来看，为什么会更加青睐REST而不是RPC（Remote Procedure Call，远程过程调用 ），因为它极大的降低了我们沟通的复杂度，通过把表征作为唯一的沟通的方式。无需去讨论过程（添加一头牛？增加一种动物类型？给鸡的数量翻倍还是卖掉所有猪？）我们只需讨论表征，并且使用这个表征来达到我们想要的目标，很简单，不是吗？我不希望和Marcus的沟通失败，因为我们彼此的理解过程会不一样，所以只需要知道最后的状态就行。但这仅仅是创建RPC会产生许多问题之一。如果你使用RPC，你需要设计一些程序嵌入到某种结构中。这种结构需要存储参数、错误的代码、返回值等。

#### 5、RPC工作原理

​		运行时,一次客户机对服务器的RPC调用,其内部操作大致有如下十步：

		1. 调用客户端句柄；执行传送参数
  		2. 调用本地系统内核发送网络消息
    		3. 消息传送到远程主机
      		4. 服务器句柄得到消息并取得参数
        		5. 执行远程过程
          		6. 执行的过程将结果返回服务器句柄
            		7. 服务器句柄返回结果，调用远程系统内核
              		8. 消息传回本地主机
                		9. 客户句柄由内核接收消息
                  		10. 客户接收句柄返回的数据

#### 6、REST工作原理

​		**HTTP正确的姿势**

		https://localhost:8080/myweb/getDogs --> GET /rest/api/dogs 获取所有小狗狗
	    https://localhost:8080/myweb/addDogs --> POST /rest/api/dogs 添加一个小狗狗 
		https://localhost:8080/myweb/updateDogs/:dog_id --> PUT /rest/api/dogs/:dog_id 修改一个小狗狗 
		https://localhost:8080/myweb/deleteDogs/:dog_id --> DELETE /rest/api/dogs/:dog_id 删除一个小狗狗
​		REST 是面向资源的，这个概念非常重要，而资源是通过 URI 进行暴露，URI 的设计只要负责把资源通过合理方式暴露出来就可以了。对资源的操作与它无关，操作是通过 HTTP动词来体现，所以REST 通过 URI 暴露资源时，会强调不要在 URI 中出现动词。

​		**REST系统的特征**

		1. `客户-服务器（Client-Server）`，提供服务的服务器和使用服务的客户需要被隔离对待。
  		2. `无状态（Stateless）`，来自客户的每一个请求必须包含服务器处理该请求所需的所有信息。换句话说，服务器端不能存储来自某个客户的某个请求中的信息，并在该客户的其他请求中使用。
    		3.  `可缓存（Cachable）`，服务器必须让客户知道请求是否可以被缓存。（Ross：更详细解释请参考 理解本真的REST架构风格 以及 StackOverflow 的这个问题 中对缓存的解释。）
      		4.  `分层系统（Layered System）`，服务器和客户之间的通信必须被这样标准化：允许服务器和客户之间的中间层（Ross：代理，网关等）可以代替服务器对客户的请求进行回应，而且这些对客户来说不需要特别支持。
        		5.  `统一接口（Uniform Interface）`，客户和服务器之间通信的方法必须是统一化的。（Ross：GET,POST,PUT.DELETE, etc）
          		6. `支持按需代码（Code-On-Demand，可选）`，服务器可以提供一些代码或者脚本（Ross：Javascrpt，flash，etc）并在客户的运行环境中执行。这条准则是这些准则中唯一不必必须满足的一条。（Ross：比如客户可以在客户端下载脚本生成密码访问服务器。）

---

### 四、坑！

​		微服务中经常会问Spring Cloud、Dubbo的区别。

|              | 框架              | 调用协议    |
| ------------ | ----------------- | ----------- |
| Spring Cloud | RPC<远程调用>框架 | RESTful协议 |
| Dubbo        | RPC<远程调用>框架 | RPC协议     |

​		剩下的就是各个模块的区别。

---

## 附录

### 1、无状态

​		 所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。有状态和无状态的区别，举个简单的例子说明一下。如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的，因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行；如果输入一个url即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个url与之对应，可以通过HTTP中的GET方法得到资源，这是典型的RESTful风格。

### 2、统一接口

​		RESTful架构风格规定，数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。

​		即：

~~~
GET（SELECT）：从服务器取出资源（一项或多项）。
POST（CREATE）：在服务器新建一个资源。
PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。
PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。
DELETE（DELETE）：从服务器删除资源。
~~~

